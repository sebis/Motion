#include "GameObject.h"
#include "RigidBody.h"

namespace Common
{
	RigidBody::RigidBody(GameObject * gameObject)
		: m_gameObject(gameObject),
		m_position(glm::vec3(0.0f)),
		m_velocity(glm::vec3(0.0f)),
		m_angularVelocity(glm::vec3(0.0f)),
		m_acceleration(glm::vec3(0.0f)),
		m_angularAcceleration(glm::vec3(0.0f)),
		m_rotation(glm::mat3(1.0f))
		//m_linearMomentum(glm::vec3(0.0f)),
		//m_angularMomentum(glm::vec3(0.0f))

	{
		m_position = gameObject->transform().position();
		// TODO: calculate these from the object we want to simulate
		m_mass = 10.0f;
		m_damping = 0.9f;
		m_angularDamping = 0.9f;

		// Inertia tensor: This could be set manually, or if not specified
		// should be calculated by all collider objects and their mass centers

		float radius = 1.0f;
		// sphere cnetered at origin
		m_inertiaTensor = glm::mat3(2.0f/5.0f * m_mass * radius * radius);
	}

	RigidBody::~RigidBody()
	{
	}

	void RigidBody::integrate(float dt)
	{
		assert(dt > 0.0f);

		// Calculate acceleration from affecting forces
		m_acceleration = (1.0f/m_mass) * m_forceAccumulator;

		// Calculate angular acceleration from affecting torques
		glm::mat3 inertiaTensor = m_rotation * m_inertiaTensor * glm::transpose(m_rotation);
		m_angularAcceleration = glm::inverse(inertiaTensor) * m_torqueAccumulator;

		// Update velocities
		m_velocity += m_acceleration * dt;
		m_angularVelocity += m_angularAcceleration * dt;

		// Calculate drag effect on velocities
		m_velocity *= glm::pow(m_damping, dt);
		m_angularVelocity *= glm::pow(m_angularDamping, dt);

		// Update position and orientation
		m_position += m_velocity * dt;

		float angle = glm::length(m_angularVelocity) * dt;
		if (angle != 0)
			m_rotation = glm::mat3(glm::rotate(glm::mat4(m_rotation), glm::degrees(angle), m_angularVelocity));

		// clear the  accumulators
		m_forceAccumulator = glm::vec3(0.0f);
		m_torqueAccumulator = glm::vec3(0.0f);

		//Trace::info("position: %f %f %f\n", m_position.x, m_position.y, m_position.z);
		//Trace::info("linearMomentum: %f %f %f\n", m_linearMomentum.x, m_linearMomentum.y, m_linearMomentum.z);

		//obj->m_linearMomentum += glm::vec3(0.0f, -9.81, 0.0f) * obj->m_mass * elapsed;
		//m_angularMomentum += torques * dt;

		//glm::mat3 inertiaTensor = m_rotation * m_inertiaTensor * glm::transpose(m_rotation);
		//glm::vec3 angularVelocity = (glm::inverse(inertiaTensor) * m_angularMomentum);
		//obj->m_velocity = (obj->m_linearMomentum / obj->m_mass);

		//obj->m_transform.translate(obj->m_velocity * elapsed);
		//m_rotation += glm::mat3(glm::cross(angularVelocity, m_rotation[0]), glm::cross(angularVelocity, m_rotation[1]), glm::cross(angularVelocity, m_rotation[2])) * dt;
	}

	void RigidBody::applyImpulse(const glm::vec3 & impulse, const glm::vec3 & point)
	{
		m_velocity += impulse * (1 / m_mass);

		// calculate impulsive torque generated by the impulse with the given contact point
		glm::vec3 impulsiveTorque = glm::cross(point - m_position, impulse);
		//Trace::info("impulsiveTorque: %f %f %f\n", impulsiveTorque.x, impulsiveTorque.y, impulsiveTorque.z);

		glm::mat3 inertiaTensor = m_rotation * m_inertiaTensor * glm::transpose(m_rotation);
		m_angularVelocity += glm::inverse(inertiaTensor) * impulsiveTorque;

		//m_velocity -= glm::cross(m_angularVelocity, point - m_position);
		//Trace::info("angular vel: %f %f %f\n", m_angularVelocity.x, m_angularVelocity.y, m_angularVelocity.z);
	}
}
