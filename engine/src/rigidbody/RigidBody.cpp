#include "GameObject.h"
#include "RigidBody.h"

namespace Common
{
	RigidBody::RigidBody(GameObject * gameObject)
		: m_gameObject(gameObject),
		m_position(glm::vec3(0.0f)),
		m_rotation(glm::mat3(1.0f)),
		m_scale(glm::vec3(1.0f)),
		m_velocity(glm::vec3(0.0f)),
		m_angularVelocity(glm::vec3(0.0f)),
		m_acceleration(glm::vec3(0.0f)),
		m_angularAcceleration(glm::vec3(0.0f))
	{
		m_position = gameObject->transform().position();
		m_scale = gameObject->transform().scale();

		// TODO: calculate all these from the object we want to simulate
		m_mass = 0.170097139f;
		m_damping = 0.9f;
		m_angularDamping = 0.75f;

		// Inertia tensor: This could be set manually, or if not specified
		// should be calculated by all collider objects and their mass centers

		// sphere centered at origin
		float radius = 0.05715f;
		m_inertiaTensor = glm::mat3(2.0f/5.0f * m_mass * radius * radius);
	}

	RigidBody::~RigidBody()
	{
	}

	void RigidBody::integrate(float dt)
	{
		assert(dt > 0.0f);

		// Calculate acceleration from affecting forces
		m_acceleration = (1.0f/m_mass) * m_forceAccumulator;

		// Calculate angular acceleration from affecting torques
		glm::mat3 inertiaTensor = m_rotation * m_inertiaTensor * glm::transpose(m_rotation);
		m_angularAcceleration = glm::inverse(inertiaTensor) * m_torqueAccumulator;

		// Update velocities
		m_velocity += m_acceleration * dt;
		m_angularVelocity += m_angularAcceleration * dt;

		// Calculate drag effect on velocities
		m_velocity *= glm::pow(m_damping, dt);
		m_angularVelocity *= glm::pow(m_angularDamping, dt);

		// Update position and orientation
		m_position += m_velocity * dt;

		float angle = glm::length(m_angularVelocity) * dt;
		if (angle != 0)
			m_rotation = glm::mat3(glm::rotate(glm::mat4(m_rotation), glm::degrees(angle), m_angularVelocity));

		// clear the  accumulators
		m_forceAccumulator = glm::vec3(0.0f);
		m_torqueAccumulator = glm::vec3(0.0f);
	}

	void RigidBody::applyImpulse(const glm::vec3 & impulse, const glm::vec3 & point)
	{
		m_velocity += impulse * (1 / m_mass);

		// calculate impulsive torque generated by the impulse with the given contact point
		glm::vec3 impulsiveTorque = glm::cross(point - m_position, impulse);

		// calculate the angular velocity the impulsive torque generates
		glm::mat3 inertiaTensor = m_rotation * m_inertiaTensor * glm::transpose(m_rotation);
		m_angularVelocity += glm::inverse(inertiaTensor) * impulsiveTorque;
	}
}
